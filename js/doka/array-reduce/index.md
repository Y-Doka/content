---
title: "Array.reduce"
name: array-reduce
authors:
  - windrushfarer
summary:
  - редюсер редьюсер
  - свёртка
---

## Кратко

Метод массива `reduce` позволяет превратить массив в любое другое значение с помощью переданной функции-колбэка и начального значения. Функция-колбэк будет вызвана для каждого элемента массива и всегда должна возвращать результат.

## Пример

```js
const nums = [1, 2, 3, 4, 5, 6, 7, 8]

// Находим сумму элементов
const sum = nums.reduce(function (currentSum, currentNumber) {
  return currentSum + currentNumber
}, 0) // 36

const users = [
  { id: "1", name: "John" },
  { id: "2", name: "Anna" },
  { id: "3", name: "Kate" },
]

// Создаем новый объект с ключом в виде id и значением в виде имени юзера
const usernamesById = users.reduce(function (result, user) {
  return {
    ...result,
    [user.id]: user.name,
  }
}, {}) // { '1': 'John', '2': 'Anna' , '3': 'Kate' }
```

Интерактивный пример:

<p class="codepen" data-height="703" data-theme-id="light" data-default-tab="result" data-user="Windrushfarer" data-slug-hash="NWNmRje" style="height: 703px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="reduce">
  <span>See the Pen <a href="https://codepen.io/Windrushfarer/pen/NWNmRje">
  reduce</a> by Egor Ogarkov (<a href="https://codepen.io/Windrushfarer">@Windrushfarer</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

## Как пишется

Метод `reduce` принимает два параметра: функцию-колбэк и начальное значение для аккумулятора.

Сама функция-колбэк может принимать четыре параметра:

- `acc` — текущее значение аккумулятора
- `item` — элемент массива в текущей итерации
- `index` — индекс текущего элемента
- `arr` — сам массив, который мы перебираем

```js
const nums = [1, 2, 3, 4, 5, 6, 7, 8]

// Не забываем, что аккумулятор идет первым!
function findAverage(acc, item, index, arr) {
  const sum = acc + item

  // В конце вычисляем среднеарифметическое делением на кол-во элементов
  if (index === arr.length - 1) {
    return sum / arr.length
  }

  return sum
}

const average = nums.reduce(findAverage, 0) // 4.5
```

Ключом к успешному использованию `reduce` является внимательно следить за порядком аргументов и не забывать возвращать значение.

Использование `reduce` похоже на методы [forEach](/js/doka/array-foreach), [map](/js/doka/array-map) и [filter](/js/doka/array-filter), в которые так же передаётся функция-колбэк. Однако в `reduce` есть дополнительный аргумент — это текущее аккумулируемое значение. При этом можно заметить, что порядок аргументов так же немного изменён.

Функция обязательно должна возвращать значение, т.к в каждой следующей итерации значение в `acc` будет результатом, который вернулся на предыдущем шаге. Логичный вопрос, который может здесь возникнуть, — какое значение принимает `acc` во время первой итерации? Им будет являться то самое начальное значение, которые передаётся вторым аргументом в метод `reduce`

## Как это понять

Метод `reduce` крайне полезен, когда мы хотим с помощью манипуляции значениями массива вычислить какое-то новое значение. Такую операцию называют **агрегацией**. Таким образом у нас появляется мощный инструмент для обработки данных, например это может быть нахождение суммы величин в массиве или группировка в другие типы данных.

Главной особенностью `reduce`, которую важно запомнить, является наличие **аккумулятора**. Аккумулятор — это и есть то новое вычисляемое значение. Во время выполнения функции-колбэка нужно обязательно возвращать его значение, т.к оно обязательно попадает в следующую итерацию, где так же будет использоваться для дальнейших вычислений. Таким образом мы можем представить аккумулятор как переменную, значение которой можно поменять в каждой новой итерации. С помощью второго аргумента в `reduce` эта переменная получает своё начальное значение.

```js
// Задача: вычислить сумму денег на всех счетах
const bankAccounts = [
  { id: "123", amount: 19 },
  { id: "345", amount: 33 },
  { id: "567", amount: 4 },
  { id: "789", amount: 20 },
]

const totalAmount = bankAccounts.reduce(
  // Аргумент sum является аккумулятором, в нем храним промежуточное значение
  function (sum, currentAccount) {
    // Каждую итерацию берем текущее значение и складываем его с количеством
    // денег на текущем счету
    return sum + currentAccount.amount
  },
  0 // Начальное значение, которые инициализирует аккумулятор
) // Получим 76
```

Чтобы понять этот момент можно ещё посмотреть на код, который делает то же самое, но уже без `reduce`:

```js
// Задача: вычислить сумму денег на всех счетах
const bankAccounts = [
  { id: "123", amount: 19 },
  { id: "345", amount: 33 },
  { id: "567", amount: 4 },
  { id: "789", amount: 20 },
]

// Определяем где будем хранить сумму, это в нашем случае является аккумулятором,
// здесь же определяем начальное значение аккумулятора
let totalAmount = 0

for (let i = 0; i < bankAccounts.length; i++) {
  const currentAccount = bankAccounts[i]

  // В каждой итерации прибавляем к текущей сумме количество денег на счету
  totalAmount += currentAccount.amout
}

totalAmount // Будет так же равен 76
```

И в том и в том другом примере у нас аккумулятор, где хранится текущее значение и кладётся новое, есть вычисление нового значение. Только `reduce` позволяет сделать это в одном месте и более понятном декларативном стиле.
